/**
 * Drupal Gulp: Entry Point.
 */

"use strict";

import path from "path";
import fs from "fs";
import {globSync} from "glob";

/**
 * Drupal Extension.
 */
export class DrupalExtension {

  constructor(path) {
    this.path = path;
  }

  /**
   * Get glob patterns for style sources.
   *
   * @returns {string[]} Glob patterns.
   */
  getStyleSourcePatterns() {
    return [
      path.join(this.path, '**', '*.scss'),
    ];
  }

  /**
   * Get glob patterns for script sources.
   *
   * @returns {string[]} Glob patterns.
   */
  getScriptSourcePatterns() {
    return [
      path.join(this.path, '**', '*.js'),
    ];
  }

  /**
   * Get glob patterns for style destinations.
   *
   * Matched files are deemed suitable for deletion as they can be
   * re-generated with Gulp.
   *
   * @returns {string[]} Glob patterns.
   */
  getStyleDestinationPatterns() {
    return [
      path.join(this.path, 'dist', '*.min.css'),
      path.join(this.path, 'dist', '*.css.map'),
      path.join(this.path, 'components', '**', '*.min.css'),
      path.join(this.path, 'components', '**', '*.css.map'),
    ];
  }

  /**
   * Get glob patterns for script destinations.
   *
   * Matched files are deemed suitable for deletion as they can be
   * re-generated with Gulp.
   *
   * @returns {string[]} Glob patterns.
   */
  getScriptDestinationPatterns() {
    return [
      path.join(this.path, 'dist', '*.min.js'),
      path.join(this.path, 'dist', '*.js.map'),
      path.join(this.path, 'components', '**', '*.min.js'),
      path.join(this.path, 'components', '**', '*.js.map'),
    ];
  }

}

/**
 * Configuration Object.
 */
export class Config {

  /**
   * Create a configuration object with the given parameters.
   *
   * @param {string} projectRoot
   * @param {string} drupalRoot
   * @param {string[]} styleSources
   * @param {string[]} styleDestinations
   * @param {string[]} styleIgnores
   * @param {string[]} scriptSources
   * @param {string[]} scriptDestinations
   * @param {string[]} scriptIgnores
   * @param {{}} options
   */
  constructor(
    projectRoot,
    drupalRoot,
    styleSources,
    styleDestinations,
    styleIgnores,
    scriptSources,
    scriptDestinations,
    scriptIgnores,
    options,
  ) {
    /**
     * Path to the root of the Composer project.
     *
     * This is where the project's main composer.json exists.
     *
     * @type {string}
     *
     * @todo Consider removing if unused.
     */
    this.projectRoot = projectRoot;

    /**
     * Path to the root of the Drupal installation.
     *
     * This is where Drupal's index.php exists.
     *
     * @type {string}
     *
     * @todo Consider removing if unused.
     */
    this.drupalRoot = drupalRoot;

    /**
     * Globs to directories where style sources exist.
     *
     * @type {string[]}
     */
    this.styleSources = styleSources || [];

    /**
     * Globs to generated styles.
     *
     * These patterns match files that are generated by the build process.
     * Such files are deemed safe to delete because they can be regenerated
     * from the sources.
     *
     * @type {string[]}
     */
    this.styleDestinations = styleDestinations || [];

    /**
     * Globs to files that should not be treated as sources.
     *
     * These patterns match files which will be ignored by the build process.
     *
     * @type {string[]}
     */
    this.styleIgnores = styleIgnores || [];

    /**
     * Globs to directories where script sources exist.
     *
     * @type {string[]}
     */
    this.scriptSources = scriptSources || [];

    /**
     * Globs to generated scripts.
     *
     * These patterns match files that are generated by the build process.
     * Such files are deemed safe to delete because they can be regenerated
     * from the sources.
     *
     * @type {string[]}
     */
    this.scriptDestinations = scriptDestinations || [];

    /**
     * Globs to files that should not be treated as sources.
     *
     * These patterns match files which will be ignored by the build process.
     *
     * @type {string[]}
     */
    this.scriptIgnores = scriptIgnores || [];

    /**
     * Options for plugins, keyed by Plugin ID.
     *
     * @type {Object.<string, any>}
     */
    this.options = options || {};
  }

  /**
   * Get options for a plugin.
   *
   * @param {string} key Options key.
   *   Usually, this is the name of a plugin. Example: uglify.
   * @return {Object} Options object.
   */
  getOptionsFor(key) {
    return this.options[key] || {};
  }

  /**
   * Set options for a plugin.
   *
   * @param {string} key Options key.
   *   Usually, this is the name of a plugin. Example: uglify.
   * @param {Object} opts Options object.
   *
   * @return {this}
   */
  setOptionsFor(key, opts) {
    this.options[key] = opts;
    return this;
  }

}

/**
 * Configuration Helper.
 */
export class ConfigHelper {

  /**
   * Create a Configuration Helper.
   *
   * @param {string} projectRoot Project root.
   *   Path to the root of the project where the package.json file is placed.
   * @param {string|null} drupalRoot
   *   Path to the directory containing Drupal's index.php.
   */
  constructor(projectRoot, drupalRoot = null) {
    this.projectRoot = projectRoot;
    this.drupalRoot = drupalRoot || this._detectDrupalRoot();
  }

  /**
   * Auto-detect Drupal root.
   *
   * @returns {string}
   * @private
   */
  _detectDrupalRoot() {
    const entries = ['web', 'docroot'];
    for (const entry of entries) {
      const candidate = path.resolve(path.join(this.projectRoot, entry));
      if (fs.existsSync(candidate) && fs.lstatSync(candidate).isDirectory()) {
        return candidate;
      }
    }

    throw "Drupal root not detected at: " + entries.join(', ') + ".";
  }

  /**
   * Get a list of all Drupal extensions in a given set of paths.
   *
   * @param {string[]} paths Directories in which to look for extensions.
   *   Extensions are detected using their *.info.yml file.
   *
   * @returns {DrupalExtension[]}
   */
  detectExtensions(paths) {
    let patterns = paths.map(p => path.join(p, '*.info.yml'));
    let result = globSync(patterns);

    // @todo Ignore extensions that have their own package.json.
    return result.map((item) => {
      return new DrupalExtension(path.dirname(item));
    });
  }

  /**
   * Get a default configuration object.
   *
   * @returns {Config} Configuration.
   */
  getDefaults() {
    let config = new Config(
      this.projectRoot,
      this.drupalRoot,
    );

    config.styleIgnores = [
      '**/node_modules/**',
      '**/*.min.css',
    ];

    config.scriptIgnores = [
      '**/node_modules/**',
      '**/*.min.js',
    ];

    config
      .setOptionsFor('globals', [
        '$',
        'Drupal',
        'drupalSettings',
        'jQuery',
        'once',
      ])
      .setOptionsFor('uglify', {
        mangle: {},
        output: {
          comments: 'some'
        }
      });

    for (let ext of this.detectExtensions([
      path.join(this.drupalRoot, 'modules/custom/**'),
      path.join(this.drupalRoot, 'themes/custom/**'),
      path.join(this.drupalRoot, 'sites/*/modules/custom/**'),
      path.join(this.drupalRoot, 'sites/*/themes/custom/**'),
    ])) {
      config.styleSources = config.styleSources.concat(ext.getStyleSourcePatterns());
      config.scriptSources = config.scriptSources.concat(ext.getScriptSourcePatterns());

      config.styleDestinations = config.styleDestinations.concat(ext.getStyleDestinationPatterns())
      config.scriptDestinations = config.scriptDestinations.concat(ext.getScriptDestinationPatterns())
    }

    return config;
  }

}
